writeln('');
writeln('================================================ Basics ================================================');
writeln('');
writeln('');
writeln('The trivial usage is to extract an expression from a webpage like:');
writeln('  ');
writeln('   xidel http://www.example.org --extract //title');
writeln('');
writeln('Instead of one or more urls, you can also pass file names or the xml data itself (xidel "<html>.." ...). ');
writeln('The --extract option can be abbreviated as -e, and there are five different kind of extract expressions:');
writeln(' ');
writeln('  1*) XPath 2 expressions, with some changes and additional functions.');
writeln('  ');
writeln('  2 ) XQuery 1 expressions');
writeln('  ');
writeln('  3 ) CSS 3 selectors. ');
writeln(' ');
writeln('  4*) Templates, a simplified version of the page, in which the values you want to extract are annotated');
writeln('  ');
writeln('  5 ) Multipage templates, i.e. a file that contain templates for several pages');
writeln('');
writeln('The kinds marked with a * are automatically detected, the other ones have to be activated with the ');
writeln('extract-kind option. ');
writeln('CSS Selectors are also "autodetected", if they are written as css("..."),');
writeln('XQuery expressions are detected, if they start with "xquery version "1.0"; ".');
writeln('See the sections below for a more detailed description of each expression kind.');
writeln('');
writeln('');
writeln('');
writeln('The next important option is --follow (abbreviated as -f) to follow links on a page. E.g: ');
writeln('');
writeln('   xidel http://www.example.org --follow //a --extract //title ');
writeln('');
writeln('This will print the titles of all pages that are linked from http://www.example.org.');
writeln('');
writeln('--follow supports the same expressions as --extract, and it will follow the href or src attributes of the ');
writeln('usual elements, or the contained text if there are none.');
writeln('');
writeln('');
writeln('');
writeln('=====================================  Recursion / Argument order ======================================');
writeln('');
writeln('');
writeln('You can specify multiple --extract (-e) and --follow (-f) arguments to extract values from one page, ');
writeln('follow the links to the next pages and extract values from there as well ...');
writeln('Then it becomes important in which order the arguments are given, so it extracts before following, ');
writeln('or the other way around. ');
writeln('For example:');
writeln('');
writeln('a) xidel http://site1  -e "select content 1"  http://site2  -e "select content 2" ');
writeln('  ');
writeln('    This will extract content 1 from site 1 and content 2 from site 2');
writeln('');
writeln('b) xidel http://site1 http://site2 -e "select content 1"  -e "select content 2"');
writeln('');
writeln('    This will extract content 1 and 2 from site 1 as well as from site 2');
writeln('');
writeln('c) xidel http://site1  -e "select content 1"  -f "select links"     -e "select content 2"');
writeln('');
writeln('    This will extract the "content 1" from site1, and "content 2" from all sites the first site has links to. ');
writeln('    ');
writeln('d) xidel http://site1  -f "select links"      -e "select content 2" -e "select content 1"');
writeln(' ');
writeln('    This will extract "content 1" and "content 2" from all sites the first site links to, and will not ');
writeln('    extract anything from site1.    ');
writeln('');
writeln('e) xidel http://site1  -e "select content 2"  -e "select content 1" -f "select links"');
writeln('');
writeln('   This  is some kind of special case. Since -f is the last option, it will repeat the previous operation, i.e.');
writeln('   it will extract content 1 and 2 from site1 and ALL sites that can be reached by an selected link on site1 ');
writeln('   or any other of the processed sites. ');
writeln('   Only if there were another -e after -f, it would extract that from the first set of followed links and stop.');
writeln(' ');
writeln('In some kinds of extract expression you can create new variables, if you assign values to a variable called');
writeln('"_follow", that value will be included in the next follow expression. ');
writeln('If you assign an object to _follow, its properties will override the command line parameters with the same');
writeln('value. ');
writeln('');
writeln('Generally an option modifier (like --extract-kind) affects all succeeding options, unless there are none, ');
writeln('then it affects the immediate preceding option.');
writeln('');
writeln('');
writeln('========================================== XPath 2.0 / XQuery ===========================================');
writeln('');
writeln('XPath expressions provide an easy way to extract calculated values from x/html. ');
writeln('See http://en.wikipedia.org/wiki/XPath_2.0 for details.');
writeln('');
writeln('In the default configuration the XPath/XQuery implementation of Xidel deviates in a few ways from the ');
writeln('standard. However, you can disable this differences with the respective options (see link below or the');
writeln('command line parameter listing printed by --help).');
writeln('The most important changes are:');
writeln('');
writeln('  Syntax:');
writeln('  ');
writeln('    Within double-quoted strings variables are replaced, so "$var;xyz" is the same as concat($var, "xyz")');
writeln('    ');
writeln('    You can assign values to variables like:                           var := value       ');
writeln('      ');
writeln('    You can use objects with properties within the XPath expressions:  var := object(),  var.foo := "bar"');
writeln('    The properties can then be accessed by $var.foo, and are copied by object assignments, i.e.:');
writeln('    after obj2 := var, the value of $obj2.foo is $var.foo is "bar".');
writeln('    Different variables always have different objects, i.e. there are no pointers, and changing $obj2.foo ');
writeln('    in the example above, will not change $var.foo.');
writeln('    The object-constructor can take a sequence with initial parameters, e.g. obj:=object(("a", 1, "b", 2)) ');
writeln('    will create an object $obj, with $obj.a = 1 and $obj.b = 2.');
writeln('');
writeln('  ');
writeln('  Semantic:');
writeln('     ');
writeln('     All string comparisons are case insensitive, and "clever", e.g.:  ''9xy'' = ''9XY'' < ''10XY'' < ''xy''');
writeln('     This is more useful for html (think of class = ''foobar''), but can be disabled by passing collation urls');
writeln('     to the string functions. ');
writeln('     ');
writeln('     Everything is weakly typed, e.g ''false'' = false() is true, and 1 + "2" is 3. ');
writeln('');
writeln('     Unknown namespace prefixes are resolved with the namespace bindings of the input data. ');
writeln('     Therefore //a always finds all links, independent of any xmlns=".." attributes.');
writeln('     (however, if you explicitely declare a namespace like ''declare default element namespace "..."'' in XQuery, ');
writeln('     it will only find -elements in that namespace)');
writeln('');
writeln('     XML Schemas, error codes and static type checking are not supported.');
writeln('');
writeln('  Additional functions:');
writeln(' ');
writeln('    filter("string","regex"[,<match>,[<flags>]])');
writeln('                  This applies the regex "regex" to "string" and returns only the matching part. ');
writeln('                  If the <match> argument is used, only the <match>-th submatch will be returned.');
writeln('    css("sel")    This returns the nodes below the context node matched by the specified css 3 selector.');
writeln('                  You can use this to combine css and XPath, like in ''css("a.aclass")/@href''.');
writeln('    eval("xpath") This will evaluate the string "xpath" as an XPath expression');
writeln('    deep-text()   This is the concatenated plain text of the every tag inside the current text. ');
writeln('                  You can also pass a separator like deep-text('' '') to separate text of different nodes.');
writeln('    inner-xml()   This is the xml content of node ., like innerHTML in javascript.  ');
writeln('    outer-xml()   This is the same as inner-xml, but includes the node itself');
writeln('    split-equal("list", "string"[, "sep" = " "])');
writeln('                  Treats the string "list" as a list of strings separated by "sep" and tests if ');
writeln('                  "string" is contained in that list. (just like css class matching)');
writeln('    form(form, [overridden parameters = ()])');
writeln('                  Converts a html form in a http request, by url encoding all inputs descendants');
writeln('                  of the given form node. You can give a sequence of parameters to  override.');
writeln('                  e.g. form(//form[1], "foo=bar&xyz=123") returns a request for the first form,');
writeln('                  with the foo and xyz parameters overriden by bar and 123.');
writeln('                  It returns an object with .url, .method and .post properties.');
writeln('    match(<template>, <node>)');
writeln('                  Performs pattern matching between the template (see below for template documentation) ');
writeln('                  and the nodes, and returns a list or an object of matched values.');
writeln('                  For exmple match(<a>{{.}}</a>, <x><a>FOO</a><a>BAR</a></x>) returns <a>FOO</a>, and');
writeln('                  match(<a>*{{.}}</a>, <x><a>FOO</a><a>BAR</a></x>) returns (<a>FOO</a>, <a>BAR</a>).');
writeln('                  It is also possible to use named variables in the template, in which case an object ');
writeln('                  is returned, e.g:');
writeln('                    match(<x><a>{{first:=.}}</a><a>{{second:=.}}</a></x>, <x><a>FOO</a><a>BAR</a></x>)');
writeln('                  returns an object with two properties "first" and "bar", containing respectively');
writeln('                    <a>FOO</a> and <a>BAR</a>.');
writeln('                  The template can be a node or a string. Written as string the above example would be');
writeln('                    match("<a>{.}</a>", <x><a>FOO</a><a>BAR</a></x>).');
writeln('                 ');
writeln('');
writeln('');
writeln('The pasdoc documentation of my XPath 2 / XQuery library explains more details:');
writeln('http://www.benibela.de/documentation/internettools/xquery.TXQueryEngine.html');
writeln('');
writeln('');
writeln('========================================== CSS 3.0 Selectors ==========================================');
writeln('');
writeln('');
writeln('CSS 3 Selectors are fully supported, except some pseudoclasses like :hover and ::before that do not ');
writeln('make sense in a gui less, reading-only application.');
writeln('(It is however not much tested, since I personally only use XPath)');
writeln('');
writeln('The easiest way to use CSS selectors with the command line is to write it like --extract "css(''selector'')"');
writeln('(the "-quotes are necessary to escape the ''-quotes.) ');
writeln('');
writeln('Alternatively you can use --extract-kind=css --extract=selector. ');
writeln('');
writeln('');
writeln('============================================== Templates ==============================================');
writeln('');
writeln('Templates are a very easy way to extract complex data from a webpage. ');
writeln('Each template is basically a stripped-down excerpt of the webpage, in which the relevant parts have ');
writeln('been annotated.');
writeln('');
writeln('The best way to describe templates is with a real world example:');
writeln('');
writeln('The following is the html of an entry of one of the recommended videos you can always see at the right');
writeln('side of an youtube video: (skipped the image part for clarity)');
writeln('');
writeln('  <li class="video-list-item">');
writeln('    <a href="/watch?v=F6SeX76_F5Q&amp;feature=related" class="related-video yt-uix-contextlink yt-uix-sessionlink" ');
writeln('       data-sessionlink="ved=CBQQzRooEQ%3D%3D&amp;ei=CIDyscip97ECFcWw3godn3H0ug%3D%3D&amp;feature=related">');
writeln('      <!-- skipped -->');
writeln('      <span dir="ltr" class="title" title="Idras Sunhawk Lyrics">Idras Sunhawk Lyrics</span>');
writeln('      <span class="stat attribution">by <span class="yt-user-name " dir="ltr">FolkAndPaganSongs</span></span>');
writeln('      <span class="stat view-count">5.634 views</span>');
writeln('    </a>');
writeln('  </li>');
writeln('');
writeln('As you see there are actual interesting values like the url/title/username/view texts, and irrelevant, ');
writeln('changing values like the session url.');
writeln('If you now remove the irrelevant parts, and annotate the interesting values as {name:=value}, ');
writeln('you get the following:');
writeln('');
writeln('  <li class="video-list-item">');
writeln('    <a>');
writeln('      <span dir="ltr" class="title">{title:=.}</span>');
writeln('      <span class="stat attribution"><span class="yt-user-name " dir="ltr">{username:=.}</span></span>');
writeln('      <span class="stat view-count">{views:=filter(., "[0-9.]+")}</span>');
writeln('      {url := @href}');
writeln('    </a>');
writeln('  </li>+');
writeln('');
writeln('This template can directly passed as an extract-expression, applied to the page of an youtube video,');
writeln('and will return all recommended/related videos.');
writeln('More precisely, it will return four (interleaved) arrays "title", "username", "views", "url" each ');
writeln('containing the relevant values.');
writeln('');
writeln('A basic template as above consists of three different kind of expressions:');
writeln('');
writeln(' <li .../>   A normal html element will be matched to the processed html page.');
writeln('             This means it will search the first element on the page, that has the same node name,');
writeln('             all the attributes with the same values, and whose children match the children of the ');
writeln('             template element.             ');
writeln(' ');
writeln(' {..}        A {} marker will execute the contained XPath expression, once the corresponding ');
writeln('             place in the html page has been found. ');
writeln('             The context node . will refer to the surrounding element, and you can use my extended ');
writeln('             XPath syntax (var := value) to create a variable. (see XPath above)');
writeln('             Often you want to read the entire matched element in a variable with $name, which');
writeln('             can be written as {$name := .} or further abbreviated as {$name} .             ');
writeln('             It can also be used within attributes, like <a x="{.}"/> to read the attribute value.');
writeln('             (the parentheses can be also replaced by <template:s>..</template:s> or <t:s>..</t:s>)');
writeln('             ');
writeln(' ');
writeln('  +          Finally the loop marker will repeat the matching of the previous element as long as ');
writeln('             possible (an similar syntax is <t:loop>..</t:loop> or <t:loop>..</t:loop>).');
writeln('            ');
writeln('            ');
writeln('');
writeln('This is sufficient for most basic scraping operations, but you can also use the following things in a ');
writeln('template:');
writeln(' ');
writeln(' textnodes                Textnodes are matched like html element nodes.');
writeln('                          A textnode in the webpage is considered a valid match, if it starts');
writeln('                          with the same text as the text node in the template.');
writeln('                          (but you can change this behavior to ends-with/exact/regex-comparisons with ');
writeln('                          the  <t:meta [default-text-matching="??"] [default-case-sensitive="??"]/>');
writeln('                          command)');
writeln(' ');
writeln(' <t:if test="??"/>        All children of a template:if-tag are ignored if the test-XPath-expressions ');
writeln('                          evaluates to false()');
writeln(' ');
writeln(' <t:switch [value="??"]>  Only one of the child elements will be used for matching');
writeln('');
writeln(' <t:switch-prioritized>   Same a t:switch, but it will choose the earliest template child that has a match.');
writeln(' ');
writeln(' t:optional="true"        Html nodes can be marked as optional, and they will be ignored, if no possible');
writeln('                          match can be found');
writeln(' ');
writeln(' t:condition="??"         An XPath expression that c be The context node (.) refers to a potential match.');
writeln(' ');
writeln(' *                        Like +, but it can also match none');
writeln(' ');
writeln(' {min,max} or {count}     Matches between [min,max] or {count}-many occurrences of the previous element');
writeln(' ');
writeln(' ');
writeln(' <t:loop min=.. max=../>  The same as above. However, t:loop will repeat all its children, while a marker ');
writeln('                          like + can only repeat the single, previous element.');
writeln('                          ');
writeln(' ?                        Short notation for t:optional. ');
writeln(' ');
writeln('(see http://www.benibela.de/documentation/internettools/extendedhtmlparser.THtmlTemplateParser.html ');
writeln(' for  more detailed explanations)');
writeln(' ');
writeln('');
writeln('There is also a Greasemonkey script to create templates directly by just selecting the text on the ');
writeln('corresponding webpage.');
writeln('');
writeln('');
writeln('');
writeln('========================================= Multipage templates ==========================================');
writeln('');
writeln('Multipage templates collect several single page templates in a xml file.');
writeln('They are basically just a list of <page/> nodes with <post/> data and associated <template/>s');
writeln('E.g.');
writeln('');
writeln('  <action>');
writeln('    <page url="http://www.example.org/url">');
writeln('      <post name="var">unescaped post data</post>');
writeln('      <post>your=escaped&post=data&...</post>');
writeln('      <template> ');
writeln('        <a>{alink:=.}</a>* ');
writeln('      </template>');
writeln('    </page>');
writeln('    ');
writeln('    <page ...> ... </page>');
writeln('    ');
writeln('    ...');
writeln('  </action>');
writeln('');
writeln('All pages are downloaded with GET or respectively POST requests, and processed with the given template.');
writeln('The page-node also accepts a "test" attribute, which gives an XPath expression that needs to be true, ');
writeln('if the page element should be used.');
writeln('You can use $..; variables in the attributes and post-nodes. ');
writeln('');
writeln('Since this would be cumbersome to pass directly to --extract, you can also specify the containing file');
writeln('with the --template-file argument.');
writeln('');
writeln('You can also have multiple <action/>s in a multipage template (surrounded by a parent element with ');
writeln('name <actions>), and call the later actions with <call action=".."/> from another action.');
writeln('If a template with multiple actions is passed to Xidel it will always perform the first action,');
writeln('unless the --template-action parameter specifies another action to run. (in Xidel > 0.5)');
writeln('');
writeln('There are also <variable>-elements to declare variables and <loop>-elements to repeat other elements, ');
writeln('see http://www.benibela.de/documentation/internettools/multipagetemplate.TMultiPageTemplate.html');
writeln('for more details.');
writeln('');
writeln('=========================================== Output formats =============================================');
writeln('');
writeln('Xidel has three different output formats, which can be chosen with the output-format option:');
writeln('');
writeln('adhoc:  A very simple format, it will just print all values (default)');
writeln('');
writeln('json:   It will print valid json. ');
writeln('        Sequences become arrays [ ... ].');
writeln('        Objects become objects. {"prop-1": "value 1", "prop-2": "value 2", ... }       ');
writeln('');
writeln('xml:    It will print valid xml.');
writeln('        Sequences will become <seq><e>value 1</e><e>value 2</e>...</seq>');
writeln('        Objects will become <object><property-1>value 1</property-1><prop-2>..</prop-2>..</object>');
writeln('');
writeln('Generally it prints a sequence of all processed pages (i.e. each page a single sequence element), ');
writeln('and variables read by template become object properties.');
writeln('There is a special rule for json template output, if the template assigns multiple values to the same');
writeln('variable: Xidel will collect all these values in an array. I.e. (a:=1, b:=2, a:=3, c:=4)');
writeln('becomes "a": [1, 3], "b": 2. "c": 4');
writeln('');
writeln('');
writeln('');
writeln('');
writeln('');
