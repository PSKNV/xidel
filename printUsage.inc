writeln('');
writeln('================================================ Basics ================================================');
writeln('');
writeln('');
writeln('The trivial usage is to extract an expression from a webpage like:');
writeln('  ');
writeln('   xidel http://www.example.org --extract //title');
writeln('');
writeln('Instead of one or more urls, you can also pass file names or the xml data itself (xidel "<html>.." ...). ');
writeln('The --extract option can be abbreviated as -e, and there are few different kind of extract expressions:');
writeln(' ');
writeln('  1 ) XPath 2 expressions, with some changes and additional functions.');
writeln('  ');
writeln('  2 ) XQuery 1 expressions');
writeln('  ');
writeln('  3 ) CSS 3 selectors. ');
writeln(' ');
writeln('  4 ) Templates, a simplified version of the page which is pattern matched against the input');
writeln('  ');
writeln('  5 ) Multipage templates, i.e. a file that contains templates for several pages');
writeln('  ');
writeln('  6 ) (XPath 3 and XQuery 3 expressions, but they are work in progress and very incomplete  )');
writeln('');
writeln('The different kinds except multipage templates are usually automatically detected, but ');
writeln('a certain type can be forced with the extract-kind option.');
writeln('Or by using the shorter --xpath "..", --xquery "..", --css ".." options.');
writeln('Especially XQuery and template expressions are easily confused by the auto detector. ');
writeln('(Xidel assumes templates, if the expression starts with a "<" )');
writeln('');
writeln('See the sections below for a more detailed description of each expression kind.');
writeln('');
writeln('');
writeln('');
writeln('The next important option is --follow (abbreviated as -f) to follow links on a page. E.g: ');
writeln('');
writeln('   xidel http://www.example.org --follow //a --extract //title ');
writeln('');
writeln('This will print the titles of all pages that are linked from http://www.example.org.');
writeln('');
writeln('--follow supports the same expressions as --extract, and it will follow the href or src attributes of the ');
writeln('usual elements, or the contained text if there are no such attributes.');
writeln('');
writeln('');
writeln('');
writeln('==============================  Recursion / Argument order and grouping ===============================');
writeln('');
writeln('');
writeln('You can specify multiple --extract (-e) and --follow (-f) arguments to extract values from one page, ');
writeln('follow the links to the next pages and extract values from there as well ...');
writeln('Thereby it is important in which order the arguments are given, so e.g. it extracts before following, ');
writeln('and not the other way around.  ');
writeln('You can usually read it left-to-right like an English sentence, extracting from the current page,');
writeln('or following to a new one, which will then become the next current page.');
writeln('For example:');
writeln('');
writeln('a) xidel http://site1  -e "select content 1"  http://site2  -e "select content 2" ');
writeln('  ');
writeln('    This will extract content 1 from site 1 and content 2 from site 2');
writeln('');
writeln('b) xidel http://site1 http://site2 -e "select content 1"  -e "select content 2"');
writeln('');
writeln('    This will extract content 1 and 2 from site 1 as well as from site 2');
writeln('');
writeln('c) xidel http://site1  -e "select content 1"     -f "//a (:select links:)"  -e "select content 2"');
writeln('');
writeln('    This will extract the "content 1" from site1, and "content 2" from all sites the first site has links to. ');
writeln('    ');
writeln('d) xidel http://site1  -f "//a (:select links:)" -e "select content 1"      -e "select content 2"');
writeln(' ');
writeln('    This will extract "content 1" and "content 2" from all sites the first site links to, and will not ');
writeln('    extract anything from site1.    ');
writeln('');
writeln('e) xidel http://site1  -e "select content 1"     -e "select content 2"      -f "//a (:select links:)"');
writeln('');
writeln('   This  is some kind of special case. Since -f is the last option, it will repeat the previous operation, i.e.');
writeln('   it will extract content 1 and 2 from site1 and ALL sites that can be reached by a selected link on site1 ');
writeln('   or any other of the processed sites. ');
writeln('   Only if there were another -e after -f, it would extract that from the first set of followed links and stop.');
writeln(' ');
writeln('In some kinds of extract expression you can create new variables, if you assign values to a variable called');
writeln('"_follow", that value will be included in the next follow expression. ');
writeln('If you assign an object to _follow, its properties will override the command line parameters with the same');
writeln('value. ');
writeln('');
writeln('Generally an option modifier (like --extract-kind) affects all succeeding options, unless there are none, ');
writeln('then it affects the immediate preceding option.');
writeln('');
writeln('');
writeln('');
writeln('');
writeln('You can always override the argument order by using [ and ] to group the options.');
writeln('For example:');
writeln('');
writeln('f) xidel http://site1 [ -f "//a (:select links:)" -e "select content 1" ]  -e "select content 2"');
writeln('  ');
writeln('   This will extract content 1 from all sites linked by site1 and content 2 from site1 itself.');
writeln('   I.e. the extract of content 2 is not affected by the follow-option within the [..] brackets.');
writeln('');
writeln('g) xidel http://site1 [ -f //a[@type1] --download type1/ ]   ');
writeln('                      [ -f //a[@type2] --download type2/ ]   ');
writeln('                      [ -f //a[@type3] --download type3/ ] ');
writeln('   ');
writeln('   This will download all links of type 1 in a directory type1, all links of type2 in directory type2...');
writeln('   (if written on one line)');
writeln(' ');
writeln('[ and ] must be surrounded by a space.');
writeln('');
writeln('');
writeln('');
writeln('');
writeln('');
writeln('');
writeln('========================================== XPath 2.0 / XQuery ===========================================');
writeln('');
writeln('XPath expressions provide an easy way to extract calculated values from x/html. ');
writeln('See http://en.wikipedia.org/wiki/XPath_2.0 for details.');
writeln('');
writeln('Xidel also supports JSONiq and some custom extensions, so it deviates in a few ways from the standard. ');
writeln('However, you can disable this differences with the respective options (see link below or the');
writeln('command line parameter listing printed by --help).');
writeln('Switched to full standard compatible mode, its implementation passes 99.3% of the XPath 2 only tests and ');
writeln('97.8% of the XQuery 1 tests in the XQuery Testsuite (skipping tests for invalid input queries)');
writeln('');
writeln('However, in the default mode, there are the following important extensions:');
writeln('');
writeln('  Syntax:');
writeln('  ');
writeln('    Variable assignment:                                         $var := value');
writeln('   ');
writeln('      adds $var to a set of global variables, which can be created and accessed ');
writeln('      everywhere');
writeln('');
writeln('    JSONiq literals                                           true, false, null');
writeln('    ');
writeln('      true and false are evaluated as true(), false(), null becomes jn:null()');
writeln('    ');
writeln('    JSONiq arrays:                                                     [a,b,c]');
writeln('');
writeln('       Arrays store a list of values and can be nested with each other and ');
writeln('       within sequences.');
writeln('       jn:members converts an array to a sequence.');
writeln('');
writeln('    JSONiq objects:                                      {"name": value, ...}');
writeln('    ');
writeln('       Object stores a set of values as associative map. The values can be ');
writeln('       accessed similar to a function call, e.g.: {"name": value, ...}("name").');
writeln('       Xidel also has {"name": value, ..}.name and {"name": value, ..}/name');
writeln('       as an additional, propietary syntax to access properties.');
writeln('       jn:keys or $object() returns a sequence of all property names, ');
writeln('       libjn:values a sequence of values.');
writeln('       Used with global variables, you can copy an object with obj2 := obj ');
writeln('       (objects are immutable, but properties can be changed with ');
writeln('       obj2.foo := 12, which will create a new object with the changed property)');
writeln('      ');
writeln('    Extended strings:                                                x"..{..}.."');
writeln('  ');
writeln('      If a string is prefixed by an "x", all expressions inside {}-parentheses ');
writeln('      are evaluated, like in the value of a direct attribute constructor.');
writeln('      ');
writeln('       ');
writeln('  Semantic:');
writeln('     ');
writeln('     All string comparisons are case insensitive, and "clever", e.g.: ');
writeln('              ''9xy'' = ''9XY'' < ''10XY'' < ''xy''');
writeln('     This is more useful for html (think of @class = ''foobar''), but can be ');
writeln('     disabled by passing collation urls to the string functions. ');
writeln('     ');
writeln('     Everything is weakly typed, e.g ''false'' = false() is true, and 1+"2" is 3. ');
writeln('');
writeln('     Unknown namespace prefixes are resolved with the namespace bindings of the ');
writeln('     input data. ');
writeln('     Therefore //a always finds all links, independent of any xmlns-attributes.');
writeln('     (however, if you explicitly declare a namespace like ');
writeln('     ''declare default element namespace "..."'' in XQuery, it will only find ');
writeln('     elements in that namespace)');
writeln('');
writeln('     XML Schemas, error codes and static type checking are not supported.');
writeln('');
writeln('  Certain additional functions:');
writeln('  ');
writeln('    jn:*, libjn:* The standard JSONiq and JSONlib functions');
writeln('    json("str.")  Parses a string as json, or downloads json from an url.(only use with trusted input)');
writeln('    serialize-json(value) ');
writeln('                  Converts a value to JSON');
writeln('    extract("string","regex"[,<match>,[<flags>]])');
writeln('                  This applies the regex "regex" to "string" and returns only the matching part. ');
writeln('                  If the <match> argument is used, only the <match>-th submatch will be returned.');
writeln('                  (this function used to be called "filter")');
writeln('    css("sel")    This returns the nodes below the context node matched by the specified css 3 selector.');
writeln('                  You can use this to combine css and XPath, like in ''css("a.aclass")/@href''.');
writeln('    eval("xpath") This will evaluate the string "xpath" as a XPath expression');
writeln('    system("..")  Runs a certain program and returns its stdout result as string');
writeln('    read()        Reads a line from stdin');
writeln('    deep-text()   This is the concatenated plain text of the every tag inside the current text. ');
writeln('                  You can also pass a separator like deep-text('' '') to separate text of different nodes.');
writeln('    inner-html()  This is the html content of node ., like innerHTML in javascript.  ');
writeln('    outer-html()  This is the same as inner-html, but includes the node itself');
writeln('    inner-xml()   This is the xml content of node, similar to inner-html()');
writeln('    outer-xml()   Like outer-html(), but xml-serialized');
writeln('    split-equal("list", "string"[, "sep" = " "])');
writeln('                  Treats the string "list" as a list of strings separated by "sep" and tests if ');
writeln('                  "string" is contained in that list. (just like css class matching)');
writeln('    form(form, [overridden parameters = ()])');
writeln('                  Converts a html form in a http request, by url encoding all inputs descendants');
writeln('                  of the given form node. You can give a sequence of parameters to  override.');
writeln('                  e.g. form(//form[1], "foo=bar&xyz=123") returns a request for the first form,');
writeln('                  with the foo and xyz parameters overriden by bar and 123.');
writeln('                  You can also use a JSON object to set the override parameters, e.g.');
writeln('                  {"foo": "bar", "xyz": 123}, in that case they are url encoded.');
writeln('                  It returns an object with .url, .method and .post properties.');
writeln('    match(<template>, <node>)');
writeln('                  Performs pattern matching between the template (see below for template documentation) ');
writeln('                  and the nodes, and returns a list or an object of matched values.');
writeln('                  For exmple match(<a>{{.}}</a>, <x><a>FOO</a><a>BAR</a></x>) returns <a>FOO</a>, and');
writeln('                  match(<a>*{{.}}</a>, <x><a>FOO</a><a>BAR</a></x>) returns (<a>FOO</a>, <a>BAR</a>).');
writeln('                  It is also possible to use named variables in the template, in which case an object ');
writeln('                  is returned, e.g:');
writeln('                    match(<x><a>{{first:=.}}</a><a>{{second:=.}}</a></x>, <x><a>FOO</a><a>BAR</a></x>)');
writeln('                  returns an object with two properties "first" and "bar", containing respectively');
writeln('                    <a>FOO</a> and <a>BAR</a>.');
writeln('                  The template can be a node or a string. Written as string the above example would be');
writeln('                    match("<a>{.}</a>", <x><a>FOO</a><a>BAR</a></x>).');
writeln('                 ');
writeln('    All additional functions except the jn/libjn functions are in the pxp: namespace, which is also set');
writeln('    as default namespace.');
writeln('');
writeln('The pasdoc documentation of my XPath 2 / XQuery library explains more details and lists more functions:');
writeln('http://www.benibela.de/documentation/internettools/xquery.TXQueryEngine.html');
writeln('');
writeln('');
writeln('Xidel also defines the following global default variables:');
writeln(' ');
writeln('   $raw         Unparsed input text');
writeln('   $url         Url the input was retrieved from');
writeln('   $host, $path Respective part of the url');
writeln('   $json        Parsed json input, if it was json ');
writeln('');
writeln('');
writeln('');
writeln('');
writeln('========================================== CSS 3.0 Selectors ==========================================');
writeln('');
writeln('');
writeln('CSS 3 Selectors are fully supported, except some pseudoclasses like :hover and ::before that do not ');
writeln('make sense in a gui less, reading-only application.');
writeln('(It is however not much tested, since I personally only use XPath)');
writeln('');
writeln('The easiest way to use CSS selectors with the command line is to write it like --extract "css(''selector'')"');
writeln('(the "-quotes are necessary to escape the ''-quotes.) ');
writeln('');
writeln('Alternatively you can use --extract-kind=css --extract="your selector", or --css="your selector"');
writeln('');
writeln('');
writeln('');
writeln('============================================== Templates ==============================================');
writeln('');
writeln('Templates are a very easy way to extract complex data from a webpage. ');
writeln('Each template is basically a stripped-down excerpt of the webpage, in which the relevant parts have ');
writeln('been annotated.');
writeln('');
writeln('The best way to describe templates is with a real world example:');
writeln('');
writeln('The following is the html of an entry of one of the recommended videos you can always see at the right');
writeln('side of an youtube video: (skipped the image part for clarity)');
writeln('');
writeln('  <li class="video-list-item">');
writeln('    <a href="/watch?v=F6SeX76_F5Q&amp;feature=related" class="related-video yt-uix-contextlink yt-uix-sessionlink" ');
writeln('       data-sessionlink="ved=CBQQzRooEQ%3D%3D&amp;ei=CIDyscip97ECFcWw3godn3H0ug%3D%3D&amp;feature=related">');
writeln('      <!-- skipped -->');
writeln('      <span dir="ltr" class="title" title="Idras Sunhawk Lyrics">Idras Sunhawk Lyrics</span>');
writeln('      <span class="stat attribution">by <span class="yt-user-name " dir="ltr">FolkAndPaganSongs</span></span>');
writeln('      <span class="stat view-count">5.634 views</span>');
writeln('    </a>');
writeln('  </li>');
writeln('');
writeln('As you see there are actual interesting values like the url/title/username/view texts, and irrelevant, ');
writeln('changing values like the session url.');
writeln('If you now remove the irrelevant parts, and annotate the interesting values as {name:=value}, ');
writeln('you get the following:');
writeln('');
writeln('  <li class="video-list-item">');
writeln('    <a>');
writeln('      <span dir="ltr" class="title">{title:=.}</span>');
writeln('      <span class="stat attribution"><span class="yt-user-name " dir="ltr">{username:=.}</span></span>');
writeln('      <span class="stat view-count">{views:=filter(., "[0-9.]+")}</span>');
writeln('      {url := @href}');
writeln('    </a>');
writeln('  </li>+');
writeln('');
writeln('This template can directly passed as an extract-expression, applied to the page of an youtube video,');
writeln('and will return all recommended/related videos.');
writeln('More precisely, it will return four (interleaved) arrays "title", "username", "views", "url" each ');
writeln('containing the relevant values.');
writeln('');
writeln('A basic template as above consists of three different kind of expressions:');
writeln('');
writeln(' <li .../>   A normal html element will be matched to the processed html page.');
writeln('             This means it will search the first element on the page, that has the same node name,');
writeln('             all the attributes with the same values, and whose children match the children of the ');
writeln('             template element.             ');
writeln(' ');
writeln(' {..}        A {} marker will execute the contained XPath expression, once the corresponding ');
writeln('             place in the html page has been found. ');
writeln('             The context node . will refer to the surrounding element, and you can use my extended ');
writeln('             XPath syntax (var := value) to create a variable. (see XPath above)');
writeln('             Often you want to read the entire matched element in a variable with $name, which');
writeln('             can be written as {$name := .} or further abbreviated as {$name} .             ');
writeln('             It can also be used within attributes, like <a x="{.}"/> to read the attribute value.');
writeln('             (the parentheses can be also replaced by <template:s>..</template:s> or <t:s>..</t:s>)');
writeln('             ');
writeln(' ');
writeln('  +          Finally the loop marker will repeat the matching of the previous element as long as ');
writeln('             possible (an similar syntax is <t:loop>..</t:loop> or <t:loop>..</t:loop>).');
writeln('            ');
writeln('            ');
writeln('');
writeln('This is sufficient for most basic scraping operations, but you can also use the following things in a ');
writeln('template:');
writeln(' ');
writeln(' textnodes                Textnodes are matched like html element nodes.');
writeln('                          A textnode in the webpage is considered a valid match, if it starts');
writeln('                          with the same text as the text node in the template.');
writeln('                          (but you can change this behavior to ends-with/exact/regex-comparisons with ');
writeln('                          the  <t:meta [default-text-matching="??"] [default-case-sensitive="??"]/>');
writeln('                          command)');
writeln(' ');
writeln(' <t:if test="??"/>        All children of a template:if-tag are ignored if the test-XPath-expressions ');
writeln('                          evaluates to false()');
writeln(' ');
writeln(' <t:switch [value="??"]>  Only one of the child elements will be used for matching');
writeln('');
writeln(' <t:switch-prioritized>   Same a t:switch, but it will choose the earliest template child that has a match.');
writeln(' ');
writeln(' t:optional="true"        Html nodes can be marked as optional, and they will be ignored, if no possible');
writeln('                          match can be found');
writeln(' ');
writeln(' t:condition="??"         A XPath expression that c be The context node (.) refers to a potential match.');
writeln(' ');
writeln(' *                        Like +, but it can also match none');
writeln(' ');
writeln(' {min,max} or {count}     Matches between [min,max] or {count}-many occurrences of the previous element');
writeln(' ');
writeln(' ');
writeln(' <t:loop min=.. max=../>  The same as above. However, t:loop will repeat all its children, while a marker ');
writeln('                          like + can only repeat the single, previous element.');
writeln('                          ');
writeln(' ?                        Short notation for t:optional. ');
writeln(' ');
writeln('(see http://www.benibela.de/documentation/internettools/extendedhtmlparser.THtmlTemplateParser.html ');
writeln(' for  more detailed explanations)');
writeln(' ');
writeln('');
writeln('There is also a Greasemonkey script to create templates directly by just selecting the text on the ');
writeln('corresponding webpage.');
writeln('');
writeln('');
writeln('');
writeln('========================================= Multipage templates ==========================================');
writeln('');
writeln('Multipage templates collect several single page templates in a xml file.');
writeln('They are basically just a list of <page/> nodes with <post/> data and associated <template/>s');
writeln('E.g.');
writeln('');
writeln('  <action>');
writeln('    <page url="http://www.example.org/url">');
writeln('      <post name="var">unescaped post data</post>');
writeln('      <post>your=escaped&post=data&...</post>');
writeln('      <template> ');
writeln('        <a>{alink:=.}</a>* ');
writeln('      </template>');
writeln('    </page>');
writeln('    ');
writeln('    <page ...> ... </page>');
writeln('    ');
writeln('    ...');
writeln('  </action>');
writeln('');
writeln('All pages are downloaded with GET or respectively POST requests, and processed with the given template.');
writeln('The page-node also accepts a "test" attribute, which gives an XPath expression that needs to be true, ');
writeln('if the page element should be used.');
writeln('In the attributes and the text of post-nodes, everything enclosed in {..} parentheses is evaluated');
writeln('as xpath expression. (like in an extended x".." string, see above)');
writeln('');
writeln('Since this would be cumbersome to pass directly to --extract, you can also specify the containing file');
writeln('with the --template-file argument.');
writeln('');
writeln('You can also have multiple <action/>s in a multipage template (surrounded by a parent element with ');
writeln('name <actions>), and call the later actions with <call action=".."/> from another action.');
writeln('If a template with multiple actions is passed to Xidel it will always perform the first action,');
writeln('unless the --template-action parameter specifies another action to run. ');
writeln('');
writeln('There are also <variable>-elements to declare variables and <loop>-elements to repeat other elements, ');
writeln('see http://www.benibela.de/documentation/internettools/multipagetemplate.TMultiPageTemplate.html');
writeln('for more details.');
writeln('');
writeln('=========================================== Input formats =============================================');
writeln('');
writeln('Xidel supports html and xml input, and the option input-format can be used to set the parsing behaviour:');
writeln('  ');
writeln('auto:           Automatically switch between html and xml');
writeln('  ');
writeln('html:           The input will be parsed as html. ');
writeln('                Missing tags like head, body, tbody are automatically created.');
writeln('                (beware that this means table/tr is never valid, and either table//tr or table/tbody/tr');
writeln('                has to be used)');
writeln(' ');
writeln('xml:            The input will be parsed as xml. ');
writeln('                However, it still uses the html parser, so it will correct missing end tags and not');
writeln('                support DTDs.');
writeln('                ');
writeln('xml-strict:     The input will be parsed as strict xml. ');
writeln('                This uses the standard fpc, validating xml parser.');
writeln('                ');
writeln('json:           The input will be parsed as json and stored in . and the $json variable.');
writeln('                It can be changed by assigning to $json(..)(..).. := ');
writeln('                ');
writeln('You can also use json files, by loading them explicitly with pxp:json() or jn:json-doc() within a');
writeln('XPath/XQuery expression.');
writeln('');
writeln('=========================================== Output formats =============================================');
writeln('');
writeln('Xidel has several different output formats, which can be chosen with the output-format option:');
writeln('');
writeln('adhoc:          A very simple format, it will just print all values (default)');
writeln('');
writeln('xml:            The output will be serialized as xml');
writeln('');
writeln('html:           The output will be serialized as html');
writeln('');
writeln('xml-wrapped:    It will print a xml-based machine readable output.');
writeln('                Sequences will become <seq><e>value 1</e><e>value 2</e>...</seq>');
writeln('                Objects will become <object><property-1>value 1</property-1><prop-2>..</prop-2>..</object>');
writeln('                (so in contrast to xml, it will keep variable names and type information intact)');
writeln('');
writeln('json-wrapped:   It will print a json-based machine readable output.');
writeln('                Sequences become arrays [ ... ].');
writeln('                Objects become objects. {"prop-1": "value 1", "prop-2": "value 2", ... }       ');
writeln('                (this was called json before Xidel 0.7)');
writeln('');
writeln('bash:           Prints a bash script that sets the internal variables as bash variables.');
writeln('                E.g.');
writeln('                eval $(xidel http://data -e ''title:=//title'' -e ''links:=//a'')');
writeln('                can be used to set the bash variable $title to the title of a page and the');
writeln('                variable $links to a bash array of all links on the page.');
writeln('');
writeln('cmd:            Like bash, but for Windows cmd.exe');
writeln('');
writeln('Generally it prints a sequence of all processed pages (i.e. each page a single sequence element), ');
writeln('and the variables defined as global variables or read by a template become variables or ');
writeln('object properties.');
writeln('There is a special rule for json-wrapped  output, if the template assigns multiple values to the same');
writeln('variable: Xidel will collect all these values in an array. I.e. (a:=1, b:=2, a:=3, c:=4)');
writeln('becomes "a": [1, 3], "b": 2. "c": 4');
writeln('');
writeln('');
writeln('');
writeln('');
writeln('');
