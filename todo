    xidel can be invoked with no parameters, which does nothing, yet sets exit code to 0.
    Similarly, invoking xidel with just 1 argument or forgetting to prefix the extraction expression with -e also does nothing and reports 0; e.g.:
        xidel -
        xidel - //title
    Speaking of the latter: may I suggest making the -e before the extraction expression optional, as you do with the --data option?




follow embed/@src, meta refresh url

handle base href when following

grouped compatibility options on cgi: full xquery, full jsoniq, full my own

Do not print multiple object properites with same name when printing JSON

Xidel: auto json loading, e.g. xidel filename.json -e '(.).root(2)("property")'
(required context override in xquery engine)
       
JSONiq tests

suggest similar named functions, list accepted types for type error in error message

ask on tty for password, if none is given (distinguish foo:@ and foo@ ?) 



output-header/footer should evaluate {} 

store doctype

test why download fails on large files on win (does it fail? failed twice on a slow internet connection, never with my own)

--template --multipage parameter

add download option to multipage template

JSONiq feedback:

let $foo := {"bar": 123} return $foo.bar

Porting features from JSONiq-standalone to JSONiq-extension. Like this dot notation?



--------  

GUI:
     
  reread template


-------------------------
    
PASCAL:
  CHANGE: Include submit/button if there is only one
  	
  TEST: mixing of url / follow objects
        
        how to handle differnt post data to different urls
        
  TODO: autochoose problematic when regex matches status
  	  

VIDELIBRI:
  TODO: wrong user/pass check for Stb MÃ¼nchen

-----------------------

delayed



script GUI:

  local ignore siblings

  Clear all button
    
  
  Extend (to all siblings) 
  

  formreader
  
  short notation {3,3} instead a/ a/ a/
    
attribute matching:
   regex
  
  
  
  reload without scripts
 
 
 
 
 XML Schema
  
 XPath / XQuery 3
 
 Optimizer:
   Some cases:
     
     Move constants out of loops:
        $seq[. + func($constant)]   ~~>  let $tempconstant = func($constant) return $seq[. + $tempconstant]
    
        for $i in $seq return $i + func($constant)  ~~>  let $tempconstant := func($constant) for $i in seq return . + $tempconstant
   
        every, some, ... as above
     
        $seq / func($constant)
   
    Bottom-to-Top-Evaluation?:
        evaluate constants only once, store result in term tree
        
    
    Cache big function:
        do not reparse css every time
        do not reparse regex
        
    Value sorted lists for comparisons:
        every $x in $seq satisfies $x = $seq2 ~~> let $sseq2 := sorted($seq2) return every $x in $seq satisfies $x = $sseq2
           with  $sseq2 has O(log #sseq) comparisons
 